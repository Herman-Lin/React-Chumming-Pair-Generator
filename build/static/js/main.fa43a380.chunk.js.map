{"version":3,"sources":["Components/DataInputForm.jsx","Components/OutputBox.jsx","ChummingGenerator.jsx","App.js","serviceWorker.js","index.js"],"names":["Label","this","even","undefined","odd","Array","elem","vertex","type","g","i","blossom","path","endPath","match","label","queueFront","queueBack","graph","queue","readGraph","n","e","j","initGraph","a","b","backtrace","vert","pathNum","stop","parity","direction","enqueue","t","tmp","newBlossom","base","innerBlossom","innerBase","p","augmentPath","augmentMatching","node","nodeLabel","initAlg","edmond","pairs","findMaximumMatching","push","DataInputForm","props","state","empDict","empArr","managers","toRemove","stepOneError","stepTwoError","onParticipantChangeHandler","bind","onHistoricalChangeHandler","generate","participantReader","FileReader","historicalPairReader","onload","event","workbook","XLSX","read","target","result","worksheet","Sheets","SheetNames","name","key","prev","setState","v","includes","manager","index","Object","keys","length","hasOwnProperty","prevIndex","console","log","files","readAsBinaryString","emp","JSON","stringify","toReplace","parseInt","replace","parse","setPairs","className","style","id","class","accept","onChange","for","map","email","pair","onClick","Component","OutputBox","ChummingGenerator","App","Boolean","window","location","hostname","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.fa43a380.chunk.js","sourcesContent":["import React, { Component } from 'react';\r\nimport XLSX, { read } from 'xlsx';\r\n\r\nvar MAX = 500,\r\n    undef = -2,\r\n    empty = -1,\r\n    noEdge = 0,\r\n    unmatched = 1,\r\n    matched = 2, \r\n    forward = 0,\r\n    reverse = 0;\r\n\r\n                                 //Labels are the key to this implementation of the algorithm.\r\nfunction Label(){                //An even label in a vertex means there's an alternating path\r\n       this.even = undefined;    //of even length starting from the root node that ends on the\r\n       this.odd = new Array(2);  //vertex. To find this path, the backtrace() function is called,\r\n};                               //constructing the path by following the content of the labels.\r\n                                 //Odd labels are similar, the only difference is that base nodes\r\n                                 //of blossoms inside other blossoms may have two. More on this later.\r\n\r\nfunction elem(){               //This is the element of the queue of labels to be analyzed by\r\n       this.vertex = undefined;\r\n       this.type = undefined;  //the augmentMatching() procedure. Each element contains the vertex\r\n};                             //where the label is and its type, odd or even.\r\n\r\nvar g = new Array(MAX);         //The graph, as an adjacency matrix.\r\nfor (var i=0; i<MAX; i++){\r\n  g[i] = new Array(MAX);\r\n}\r\n                              //blossom[i] contains the base node of the blossom the vertex i\r\nvar blossom = new Array(MAX); //is in. This, together with labels eliminates the need to\r\n                              //contract the graph.\r\n\r\n                              //The path arrays are where the backtrace() routine will\r\nvar path = new Array(2);\r\nfor (var i=0; i<2; i++){\r\n  path[i] = new Array(MAX);\r\n}\r\nvar endPath = new Array(2);   //store the paths it finds. Only two paths need to be\r\n                              //stored. endPath[p] denotes the end of path[p].\r\nvar match = new Array(MAX);  //An array of flags. match[i] stores if vertex i is in the matching.\r\n                  //label[i] contains the label assigned to vertex i. It may be undefined,\r\nvar label = new Array(MAX); //empty (meaning the node is a root) and a node might have even and odd\r\n                  //labels at the same time, which is the case for nonbase nodes of blossoms\r\nfor (var i=0; i<MAX; i++){\r\n  label[i] = new Label();\r\n}\r\nvar queue = new Array(2*MAX);         //The queue is necessary for efficiently scanning all labels.\r\nvar queueFront,queueBack;  //A label is enqueued when assigned and dequeued after scanned.\r\nfor (var i=0; i<2*MAX; i++){\r\n  queue[i] = new elem();\r\n}\r\n\r\nfunction initGraph(n){\r\n     for (var i=0; i<n; i++)\r\n         for (var j=0; j<n; j++) g[i][j]=noEdge;\r\n}\r\n\r\nfunction readGraph(){\r\n\r\n    var n = graph.n,\r\n        e = graph.e;\r\n\r\n    //int n,e,a,b;\r\n    //scanf(\" %d %d\",&n,&e);      //The graph is read and its edges are unmatched by default.\r\n     initGraph(n);               //Since C++ arrays are 0..n-1 and input 1..n , subtractions \r\n     for (var i=0; i<e; i++){    //are made for better memory usage.\r\n         //scanf(\" %d %d\",&a,&b);\r\n         var a = graph[i][0],\r\n             b = graph[i][1];\r\n         if (a!=b)\r\n            g[a-1][b-1]=g[b-1][a-1]=unmatched;\r\n     }\r\n     return n;\r\n}\r\n\r\nfunction initAlg(n){             //Initializes all data structures for the augmentMatching()\r\n     queueFront=queueBack=0;     //function begin. At the start, all labels are undefined,\r\n     for (var i=0; i<n; i++){    //the queue is empty and a node alone is its own blossom.\r\n         blossom[i]=i;\r\n         label[i].even=label[i].odd[0]=label[i].odd[1]=undef;\r\n     }\r\n}\r\n\r\nfunction backtrace (vert, pathNum, stop, parity, direction){\r\n     if (vert==stop) return;           //pathNum is the number of the path to store\r\n     else if (parity==0){              //vert and parity determine the label to be read.\r\n        if (direction==reverse){\r\n           backtrace(label[vert].even,pathNum,stop,(parity+1)%2,reverse);\r\n           path[pathNum][endPath[pathNum]++]=vert;\r\n        }                             //forward means the vertices called first enter\r\n        else if (direction==forward){ //the path first, reverse is the opposite.\r\n             path[pathNum][endPath[pathNum]++]=vert;\r\n             backtrace(label[vert].even,pathNum,stop,(parity+1)%2,forward);\r\n        }\r\n     }\r\n     /*\r\n       stop is the stopping condition for the recursion.\r\n       Recursion is necessary because of the possible dual odd labels.\r\n       having empty at stop means the recursion will only stop after\r\n       the whole tree has been climbed. If assigned to a vertex, it'll stop\r\n       once it's reached.\r\n     */\r\n     else if (parity==1 && label[vert].odd[1]==undef){\r\n        if (direction==reverse){\r\n           backtrace(label[vert].odd[0],pathNum,stop,(parity+1)%2,reverse);\r\n           path[pathNum][endPath[pathNum]++]=vert;\r\n        }\r\n        else if (direction==forward){\r\n             path[pathNum][endPath[pathNum]++]=vert;\r\n             backtrace(label[vert].odd[0],pathNum,stop,(parity+1)%2,forward);\r\n        }\r\n     }\r\n     /*\r\n       Dual odd labels are interpreted as follows:\r\n       There exists an odd length alternating path starting from the root to this\r\n       vertex. To find this path, backtrace from odd[0] to the top of the tree and\r\n       from odd[1] to the vertex itself. This, put in the right order, will\r\n       constitute said path.\r\n     */\r\n     else if (parity==1 && label[vert].odd[1]!=undef){\r\n          if (direction==reverse){\r\n             backtrace(label[vert].odd[0],pathNum,empty,(parity+1)%2,reverse);\r\n             backtrace(label[vert].odd[1],pathNum,vert,(parity+1)%2,forward);\r\n             path[pathNum][endPath[pathNum]++]=vert;\r\n          }\r\n          else if (direction==forward){\r\n               backtrace(label[vert].odd[1],pathNum,vert,(parity+1)%2,reverse);\r\n               backtrace(label[vert].odd[0],pathNum,empty,(parity+1)%2,forward);\r\n               path[pathNum][endPath[pathNum]++]=vert;\r\n          }\r\n     }\r\n}\r\n\r\nfunction enqueue (vert, t){\r\n     var tmp = new elem();               //Enqueues labels for scanning.\r\n     tmp.vertex=vert;        //No label that's dequeued during the execution\r\n     tmp.type=t;             //of augmentMatching() goes back to the queue.\r\n     queue[queueBack++]=tmp; //Thus, circular arrays are unnecessary.\r\n}\r\n\r\nfunction newBlossom (a, b){     //newBlossom() will be called after the paths are evaluated.\r\n     var i,base,innerBlossom,innerBase;\r\n     for (i=0; path[0][i]==path[1][i]; i++);   //Find the lowest common ancestor of a and b\r\n     i--;                                      //it will be used to represent the blossom.\r\n     base=blossom[path[0][i]];                 //Unless it's already contained in another...\r\n                                               //In this case, all will be put in the older one.\r\n     for (var j=i; j<endPath[0]; j++) blossom[path[0][j]]=base;\r\n     for (var j=i+1; j<endPath[1]; j++) blossom[path[1][j]]=base; //Set all nodes to this\r\n     for (var p=0; p<2; p++){                                     //new blossom.\r\n        for (var j=i+1; j<endPath[p]-1; j++){\r\n            if (label[path[p][j]].even==undef){        //Now, new labels will be applied\r\n               label[path[p][j]].even=path[p][j+1];    //to indicate the existence of even\r\n               enqueue(path[p][j],0);                  //and odd length paths.\r\n            }\r\n            else if (label[path[p][j]].odd[0]==undef && label[path[p][j+1]].even==undef){\r\n                 label[path[p][j]].odd[0]=path[p][j+1];\r\n                 enqueue(path[p][j],1);                 //Labels will only be put if the vertex\r\n            }                                           //doesn't have one.\r\n\r\n            else if (label[path[p][j]].odd[0]==undef && label[path[p][j+1]].even!=undef){\r\n                 /*\r\n                   If a vertex doesn't have an odd label, but the next one in the path\r\n                   has an even label, it means that the current vertex is the base node\r\n                   of a previous blossom and the next one is contained within it.\r\n                   The standard labeling procedure will fail in this case. This is fixed\r\n                   by going to the last node in the path inside this inner blossom and using\r\n                   it to apply the dual label.\r\n                   Refer to backtrace() to know how the path will be built.\r\n                 */\r\n                 innerBlossom=blossom[path[p][j]];\r\n                 innerBase=j;\r\n                 for (; blossom[j]==innerBlossom && j<endPath[p]-1; j++);\r\n                 j--;\r\n                 label[path[p][innerBase]].odd[0]=path[p][j+1];\r\n                 label[path[p][innerBase]].odd[1]=path[p][j];\r\n                 enqueue(path[p][innerBase],1);\r\n            }\r\n        }\r\n     }\r\n     if (g[a][b]==unmatched){           //All nodes have received labels, except\r\n        if (label[a].odd[0]==undef){    //the ones that called the function in\r\n           label[a].odd[0]=b;           //the first place. It's possible to\r\n           enqueue(a,1);                //find out how to label them by\r\n        }                               //analyzing if they're in the matching.\r\n        if (label[b].odd[0]==undef){\r\n           label[b].odd[0]=a;\r\n           enqueue(b,1);\r\n        }                               \r\n     }\r\n     else if (g[a][b]==matched){\r\n          if (label[a].even==undef){\r\n             label[a].even=b;\r\n             enqueue(a,0);\r\n          }\r\n          if (label[b].even==undef){\r\n             label[b].even=a;\r\n             enqueue(b,0);\r\n          }\r\n     }\r\n}\r\n\r\nfunction augmentPath (){           //An augmenting path has been found in the matching\r\n     var a,b;                  //and is contained in the path arrays.\r\n     for (var p=0; p<2; p++){\r\n         for (var i=0; i<endPath[p]-1; i++){\r\n             a=path[p][i];             //Because of labeling, this path is already\r\n             b=path[p][i+1];           //lifted and can be augmented by simple\r\n             if (g[a][b]==unmatched)   //changing of the matching status.\r\n                g[a][b]=g[b][a]=matched;\r\n             else if (g[a][b]==matched)\r\n                  g[a][b]=g[b][a]=unmatched;\r\n         }\r\n     }\r\n     a=path[0][endPath[0]-1];\r\n     b=path[1][endPath[1]-1];\r\n     if (g[a][b]==unmatched) g[a][b]=g[b][a]=matched;\r\n     else if (g[a][b]==matched) g[a][b]=g[b][a]=unmatched;\r\n     //After this, a and b are included in the matching.\r\n     match[path[0][0]]=match[path[1][0]]=true;\r\n}\r\n\r\nfunction augmentMatching (n){  //The main analyzing function, with the\r\n     var node,nodeLabel;       //goal of finding augmenting paths or\r\n     initAlg(n);               //concluding that the matching is maximum.\r\n     for (var i=0; i<n; i++) if (!match[i]){\r\n         label[i].even=empty;\r\n         enqueue(i,0);          //Initialize the queue with the exposed vertices,\r\n     }                          //making them the roots in the forest.\r\n\r\n     while (queueFront<queueBack){\r\n         node=queue[queueFront].vertex;\r\n         nodeLabel=queue[queueFront].type;\r\n         if (nodeLabel==0){\r\n            for (var i=0; i<n; i++) if (g[node][i]==unmatched){\r\n                if (blossom[node]==blossom[i]);\r\n                //Do nothing. Edges inside the same blossom have no meaning.\r\n                else if (label[i].even!=undef){\r\n                     /*\r\n                       The tree has reached a vertex with a label.\r\n                       The parity of this label indicates that an odd length\r\n                       alternating path has been found. If this path is between\r\n                       roots, we have an augmenting path, else there's an\r\n                       alternating cycle, a blossom.\r\n                     */\r\n                     endPath[0]=endPath[1]=0;\r\n                     backtrace(node,0,empty,0,reverse);\r\n                     backtrace(i,1,empty,0,reverse);\r\n                     //Call the backtracing function to find out.\r\n                     if (path[0][0]==path[1][0]) newBlossom(node,i);\r\n                     /*\r\n                       If the same root node is reached, a blossom was found.\r\n                       Start the labelling procedure to create pseudo-contraction.\r\n                     */\r\n                     else {\r\n                          augmentPath();\r\n                          return true;\r\n                          /*\r\n                            If the roots are different, we have an augmenting path.\r\n                            Improve the matching by augmenting this path.\r\n                            Now some labels might make no sense, stop the function,\r\n                            returning that it was successful in improving.\r\n                          */\r\n                     }\r\n                }\r\n                else if (label[i].even==undef && label[i].odd[0]==undef){\r\n                     //If an unseen vertex is found, report the existing path\r\n                     //by labeling it accordingly.\r\n                     label[i].odd[0]=node;\r\n                     enqueue(i,1);\r\n                }\r\n            }\r\n         }\r\n         else if (nodeLabel==1){ //Similar to above.\r\n            for (var i=0; i<n; i++) if (g[node][i]==matched){\r\n                if (blossom[node]==blossom[i]);\r\n                else if (label[i].odd[0]!=undef){\r\n                     endPath[0]=endPath[1]=0;\r\n                     backtrace(node,0,empty,1,reverse);\r\n                     backtrace(i,1,empty,1,reverse);\r\n                     if (path[0][0]==path[1][0]) newBlossom(node,i);\r\n                     else {\r\n                          augmentPath();\r\n                          return true;\r\n                     }\r\n                }\r\n                else if (label[i].even==undef && label[i].odd[0]==undef){\r\n                     label[i].even=node;\r\n                     enqueue(i,0);\r\n                }\r\n            }\r\n         }\r\n         /*\r\n           The scanning of this label is complete, dequeue it and\r\n           keep going to the next one.\r\n         */\r\n         queueFront++;\r\n     }\r\n     /*\r\n       If the function reaches this point, the queue is empty, all\r\n       labels have been scanned. The algorithm couldn't find an augmenting\r\n       path. Therefore, it concludes the matching is maximum.\r\n     */\r\n     return false;\r\n}\r\n\r\nfunction findMaximumMatching (n){\r\n     //Initialize it with the empty matching.\r\n     for (var i=0; i<n; i++) match[i]=false;\r\n     //Run augmentMatching(), it'll keep improving the matching.\r\n     //Eventually, it will no longer find a path and break the loop,\r\n     //at this point, the current matching is maximum.\r\n     while (augmentMatching(n));\r\n}\r\n\r\nfunction edmond(){\r\n    let pairs = []\r\n    var n;\r\n    n=readGraph();\r\n    findMaximumMatching(n);\r\n    for (var i=0; i<n; i++){\r\n        for (var j=i+1; j<n; j++) if (g[i][j]==matched)\r\n            pairs.push([i, j])\r\n    }\r\n    return pairs;\r\n}\r\n\r\nvar graph, toRemove\r\n\r\nclass DataInputForm extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = { \r\n      empDict: {}, \r\n      empArr: [],\r\n      managers: {}, \r\n      toRemove: [],\r\n      stepOneError: \"\",\r\n      stepTwoError: \"\"\r\n    }\r\n\r\n    this.onParticipantChangeHandler = this.onParticipantChangeHandler.bind(this)\r\n    this.onHistoricalChangeHandler = this.onHistoricalChangeHandler.bind(this)\r\n    this.generate = this.generate.bind(this)\r\n    this.participantReader = new FileReader();\r\n    this.historicalPairReader = new FileReader();\r\n    \r\n    this.participantReader.onload = (event) => {\r\n      const workbook = XLSX.read(event.target.result, {type:'binary'})\r\n      const worksheet = workbook.Sheets[workbook.SheetNames[0]];\r\n      let empDict = {}\r\n      let empArr = []\r\n      let managers = {}\r\n      let name = ''\r\n      let key = ''\r\n      let prev = 'C'\r\n      for (let i in worksheet) {\r\n        if (i === '!ref') continue\r\n        if (i === '!margins') {\r\n          if (prev !== 'C')\r\n            this.setState({stepOneError: \"Error: Last row is missing manager email.\"})\r\n          break\r\n        }\r\n        if (worksheet[i].v === undefined) {\r\n          this.setState({stepOneError: \"Error: \" + i + \" is an empty cell.\"})\r\n          break\r\n        }\r\n        if (i.includes('A')) {\r\n          if (prev !== 'C') {\r\n            this.setState({stepOneError: \"Error: \" + i + \" is missing manager email.\"})\r\n            break\r\n          }\r\n          name = worksheet[i].v\r\n          empArr.push(name)\r\n          prev = 'A'\r\n        } else if (i.includes('B')) {\r\n          if (prev !== 'A') {\r\n            this.setState({stepOneError: \"Error: \" + i + \" is missing name.\"})\r\n            break\r\n          }\r\n          key = worksheet[i].v\r\n          prev = 'B'\r\n        } else if (i.includes('C')) {\r\n          if (prev !== 'B') {\r\n            this.setState({stepOneError: \"Error: \" + i + \" is missing company email.\"})\r\n            break\r\n          }\r\n          empDict[key] = {name: name, manager: worksheet[i].v, index: Object.keys(empDict).length}\r\n          if (!managers.hasOwnProperty(worksheet[i].v)) managers[worksheet[i].v] = [key]\r\n          else managers[worksheet[i].v].push(key)\r\n          prev = 'C'\r\n        } \r\n      }\r\n      this.setState({empArr, empDict, managers})\r\n    }\r\n    this.historicalPairReader.onload = (event) => {\r\n      const workbook = XLSX.read(event.target.result, {type:'binary'})\r\n      const worksheet = workbook.Sheets[workbook.SheetNames[0]];\r\n      let prev = 'B'\r\n      let toRemove = []\r\n      let prevIndex\r\n      for (let i in worksheet) {\r\n        \r\n        if (i === '!ref') continue\r\n        if (i === '!margins') {\r\n          if (prev !== 'B')\r\n            this.setState({stepTwoError: \"Error: Last row is missing pair.\"})\r\n          break\r\n        }\r\n        if (!this.state.empDict.hasOwnProperty(worksheet[i].v)) {\r\n          this.setState({stepTwoError: \"Error: Email '\" + worksheet[i].v + \"' at Cell \" + i + \" is not in the list of participants.\"})\r\n          break\r\n        }\r\n        \r\n        if (i.includes('A')) {\r\n          if (prev !== 'B') {\r\n            this.setState({stepTwoError: \"Error: \" + i + \" has a missing pair.\"})\r\n            break\r\n          }\r\n          prevIndex = this.state.empDict[worksheet[i].v]['index']\r\n          prev = 'A'\r\n        } else if (i.includes('B')) {\r\n          if (prev !== 'A') {\r\n            this.setState({stepTwoError: \"Error: \" + i + \" has a missing pair.\"})\r\n            break\r\n          }\r\n          toRemove.push([prevIndex, this.state.empDict[worksheet[i].v]['index']])\r\n          prev = 'B'\r\n        }\r\n      }\r\n      this.setState({toRemove})\r\n      console.log(toRemove)\r\n    }\r\n  }\r\n\r\n  onParticipantChangeHandler(event) {\r\n    this.setState({stepOneError: ''})\r\n    if (event.target.files[0]) this.participantReader.readAsBinaryString(event.target.files[0]);\r\n  }\r\n\r\n  onHistoricalChangeHandler(event) {\r\n    this.setState({stepTwoError: ''})\r\n    if (event.target.files[0]) this.historicalPairReader.readAsBinaryString(event.target.files[0]);\r\n  }\r\n\r\n  generate() {\r\n    if (this.state.stepOneError || this.state.stepTwoError) return\r\n    graph = []\r\n    for (let i = 1; i < 51; i++) {\r\n      for (let j = i + 1; j < 52; j++) {\r\n          graph.push([i, j])\r\n      }\r\n    }\r\n    let toRemove = this.state.toRemove\r\n    for (let manager in this.state.managers) {\r\n      if (this.state.empDict.hasOwnProperty(manager)) {\r\n        for (let emp in this.state.managers[manager]) {\r\n          toRemove.push([this.state.empDict[manager]['index'], this.state.empDict[this.state.managers[manager][emp]]['index']])\r\n        }\r\n      }\r\n\r\n      for (let i = 0; i < this.state.managers[manager].length - 1; i++) {\r\n        for (let j = i + 1; j < this.state.managers[manager].length; j++) {\r\n          toRemove.push([this.state.empDict[this.state.managers[manager][i]]['index'], this.state.empDict[this.state.managers[manager][j]]['index']])\r\n        }\r\n       }\r\n    }\r\n    \r\n    graph = JSON.stringify(graph)\r\n    for (let i in toRemove) {\r\n      let toReplace \r\n      if (toRemove[i][0] < toRemove[i][1])\r\n          toReplace = '['+ (parseInt(toRemove[i][0]) + 1) + ',' + (parseInt(toRemove[i][1]) + 1) + ']'\r\n      else {\r\n          toReplace = '['+ (parseInt(toRemove[i][1]) + 1) + ',' + (parseInt(toRemove[i][0]) + 1) + ']'\r\n      }\r\n      graph = graph.replace(toReplace, '')\r\n    }\r\n    \r\n    const commaRegex = /,+/gi;\r\n    graph = graph.replace(commaRegex, ',')\r\n    graph = graph.replace('[,', '[')\r\n    console.log(graph)\r\n    graph = JSON.parse(graph)\r\n    graph[\"n\"] = Object.keys(this.state.empDict).length;\r\n    graph[\"e\"] = graph.length;\r\n    this.props.setPairs(edmond(), this.state.empDict)\r\n    \r\n    this.setState({toRemove})\r\n  }\r\n  \r\n  render() {\r\n    return (\r\n      <div>\r\n        <div className=\"form-frame\">\r\n        <form style={({\"height\": \"90vh\"})}>\r\n            <div className=\"name-input\">\r\n                <h1 className=\"form-header\">Step 1: Input Names</h1>\r\n                <input \r\n                    type=\"file\" \r\n                    name=\"excel-file-participants\" \r\n                    id=\"excel-file-participants\" \r\n                    class=\"file-upload\"\r\n                    accept=\".xlsx\"\r\n                    onChange={this.onParticipantChangeHandler}\r\n                ></input>\r\n                <label for=\"excel-file-participants\">Upload Excel File</label>\r\n                <p className=\"error-text\">{this.state.stepOneError}</p>\r\n                {Object.keys(this.state.empDict).length > 0 ? \r\n                <p className=\"info-text\"> Added {Object.keys(this.state.empDict).length} participants</p> \r\n                : <div/>}\r\n                {Object.keys(this.state.empDict).length > 0 ? \r\n                <div className=\"name-list\">\r\n                  {\r\n                    Object.keys(this.state.empDict).map((email, index) => {\r\n                    return <p className=\"names\" key={'emp-' + index}>{index + 1 + '. ' + this.state.empDict[email]['name'] + \" (\" + email + \")\"}</p>\r\n                    })\r\n                  }\r\n                </div>\r\n                : <div/>\r\n                }\r\n            </div>\r\n            <div className=\"name-input\">\r\n                <h1 className=\"form-header\">Step 2: Input Historical Pairs</h1>\r\n                <input \r\n                    type=\"file\" \r\n                    name=\"excel-file-historical\" \r\n                    id=\"excel-file-historical\" \r\n                    class=\"file-upload\"\r\n                    accept=\".xlsx\"\r\n                    onChange={this.onHistoricalChangeHandler}\r\n                ></input>\r\n                <label for=\"excel-file-historical\">Upload Excel File</label>\r\n                <p className=\"error-text\">{this.state.stepTwoError}</p>\r\n                {Object.keys(this.state.toRemove).length > 0 ? \r\n                <p className=\"info-text\"> Added {this.state.toRemove.length} exclusions</p> \r\n                : <div/>}\r\n                {Object.keys(this.state.toRemove).length > 0 ? \r\n                <div className=\"name-list\">\r\n                  {\r\n                    this.state.toRemove.map((pair, index) => {\r\n                      return <p className=\"names\" key={'rem-' + index}>\r\n                              {this.state.empDict[Object.keys(this.state.empDict)[pair[0]]].name}+ \r\n                              {this.state.empDict[Object.keys(this.state.empDict)[pair[1]]].name}\r\n                            </p>\r\n                    })\r\n                  }\r\n                </div>\r\n                : <div/>}\r\n            </div>\r\n        </form>\r\n      </div>\r\n        <div className=\"submit-column\">\r\n          <button type=\"button\" onClick={this.generate}className=\"submit-button\">Generate</button>\r\n        </div>\r\n      </div>\r\n      \r\n    );\r\n  }\r\n}\r\n\r\nexport default DataInputForm;","import React, { Component } from 'react';\r\n\r\nclass OutputBox extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n  }\r\n  \r\n  render() {\r\n    return (\r\n      <div className=\"output-box\">\r\n        {this.props.pairs.length > 0 ? <h1 className=\"result-header\"> Here are the chumming pairs: </h1>: <div/>}\r\n        <table className=\"pair-display\">\r\n          {\r\n            this.props.pairs.map( (pair, index) => {\r\n              return <tr key={\"row-\" + index}>\r\n                        <td>{this.props.empDict[Object.keys(this.props.empDict)[pair[0]]].name}</td>\r\n                        <td>{this.props.empDict[Object.keys(this.props.empDict)[pair[1]]].name}</td>\r\n                      </tr>\r\n            })\r\n          }\r\n        </table>\r\n        {this.props.pairs.length > 0 ? <h1 className=\"result-header\"> Attach this to an historical pairing excel sheet: </h1>: <div/>}\r\n        <table className=\"pair-display\">\r\n          {\r\n            this.props.pairs.map( (pair, index) => {\r\n              return <tr key={\"row-\" + index}>\r\n                        <td>{Object.keys(this.props.empDict)[pair[0]]}</td>\r\n                        <td>{Object.keys(this.props.empDict)[pair[1]]}</td>\r\n                      </tr>\r\n            })\r\n          }\r\n        </table>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default OutputBox;","import React, { Component } from 'react';\r\nimport DataInputForm from './Components/DataInputForm'\r\nimport OutputBox from './Components/OutputBox'\r\n\r\nclass ChummingGenerator extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n    this.state = {pairs: [], empDict: {}}\r\n  }\r\n  render() {\r\n    return (\r\n      <div>\r\n        <DataInputForm setPairs={(pairs, empDict) => this.setState({pairs, empDict})}/>\r\n        <OutputBox pairs={this.state.pairs} empDict={this.state.empDict}/>\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default ChummingGenerator;","import React from 'react';\nimport ChummingGenerator from './ChummingGenerator'\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <ChummingGenerator/>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}